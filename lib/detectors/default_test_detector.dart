import 'package:analyzer/dart/ast/ast.dart';
import 'package:dnose/detectors/abstract_detector.dart';
import 'package:dnose/models/test_class.dart';
import 'package:dnose/models/test_smell.dart';
import 'package:dnose/utils/util.dart';

class DefaultTestDetector implements AbstractDetector {
  @override
  get testSmellName => "Default Test";

  String? codeTest;
  int startTest = 0, endTest = 0;

  List<TestSmell> testSmells = List.empty(growable: true);

  @override
  List<TestSmell> detect(
    ExpressionStatement e,
    TestClass testClass,
    String testName,
  ) {
    codeTest = e.toSource();
    startTest = testClass.lineNumber(e.offset);
    endTest = testClass.lineNumber(e.end);

    if (_isDefaultFlutterTest(e, testName)) {
      testSmells.add(
        TestSmell(
          name: testSmellName,
          testName: testName,
          testClass: testClass,
          code: e.toSource(),
          codeMD5: Util.md5(e.toSource()),
          codeTest: codeTest,
          codeTestMD5: Util.md5(codeTest!),
          startTest: startTest,
          endTest: endTest,
          start: testClass.lineNumber(e.offset),
          end: testClass.lineNumber(e.end),
          collumnStart: testClass.columnNumber(e.offset),
          collumnEnd: testClass.columnNumber(e.end),
          offset: e.offset,
          endOffset: e.end,
        ),
      );
    }

    return testSmells;
  }

  @override
  void reset() {
    testSmells.clear();
  }

  bool _isDefaultFlutterTest(ExpressionStatement e, String testName) {
    // Check if it's a testWidgets call
    if (e.expression is! MethodInvocation) return false;
    var methodInvocation = e.expression as MethodInvocation;

    if (methodInvocation.methodName.name != 'testWidgets') return false;

    // Check if the test name contains "Counter increments smoke test"
    if (!testName.contains('Counter increments smoke test')) return false;

    // Check the function body for characteristic patterns
    if (methodInvocation.argumentList.arguments.length < 2) return false;
    var functionExpr = methodInvocation.argumentList.arguments[1];

    if (functionExpr is! FunctionExpression) return false;

    String bodyText = functionExpr.body.toSource().toLowerCase();

    // Check for key patterns in the default Flutter test
    bool hasPumpWidget = bodyText.contains('pumpwidget');
    bool hasFindText = bodyText.contains('find.text');
    bool hasFindsOneWidget = bodyText.contains('findsonewidget');
    bool hasFindsNothing = bodyText.contains('findsnothing');
    bool hasTap = bodyText.contains('tap');
    bool hasByIcon = bodyText.contains('byicon');
    bool hasIconsAdd = bodyText.contains('icons.add');

    return hasPumpWidget && hasFindText && hasFindsOneWidget &&
           hasFindsNothing && hasTap && hasByIcon && hasIconsAdd;
  }

  @override
  String getDescription() {
    return '''
        Occurs when a test method contains the default Flutter counter test code that was
        auto-generated by Flutter. This indicates that the test has not been customized
        for the specific application and may not be testing meaningful functionality.
        Such tests should be modified or removed to ensure proper test coverage.
        ''';
  }

  @override
  String getExample() {
    return '''
        testWidgets('Counter increments smoke test', (WidgetTester tester) async {
          // Build our app and trigger a frame.
          await tester.pumpWidget(new MyApp());

          // Verify that our counter starts at 0.
          expect(find.text('0'), findsOneWidget);
          expect(find.text('1'), findsNothing);

          // Tap the '+' icon and trigger a frame.
          await tester.tap(find.byIcon(Icons.add));
          await tester.pump();

          // Verify that our counter has incremented.
          expect(find.text('0'), findsNothing);
          expect(find.text('1'), findsOneWidget);
        });
        ''';
  }
}
